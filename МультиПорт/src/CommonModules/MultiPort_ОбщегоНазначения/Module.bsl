
#Область СлужебныеПроцедурыИФункции

#Область Фабрика

// Возвращает фабрику XDTO из указанных схем XSD
//
// Параметры:
//  МассивСхемXSD - Массив из Строка - строковые значения схем XSD
// 
// Возвращаемое значение:
//  ФабрикаXDTO - Фабрика сформированная на основе переданных схем
//
Функция ПолучитьИзСхемФабрикуXDTO(МассивСхемXSD) Экспорт
	
	НаборСхемXML = Новый НаборСхемXML;
	
	Для Каждого СхемаXSD из МассивСхемXSD Цикл 
	
		ЧтениеСхемыXML = Новый ЧтениеXML;
		ЧтениеСхемыXML.УстановитьСтроку(СхемаXSD);
		ПостроительDOM = Новый ПостроительDOM;
		ДокументDOM = ПостроительDOM.Прочитать(ЧтениеСхемыXML);
		ПостроительСхемXML = Новый ПостроительСхемXML;
		СхемаXML = ПостроительСхемXML.СоздатьСхемуXML(ДокументDOM);		
		НаборСхемXML.Добавить(СхемаXML); 
		
	КонецЦикла;
	
	ФабрикаXDTOПроцессинга = Новый ФабрикаXDTO(НаборСхемXML); 
	Возврат ФабрикаXDTOПроцессинга;
	
КонецФункции	
	
// Функция на основе текста запроса получает структуру таблиц и полей запроса
// Параметры:
//	ТекстЗапроса - Строка - Текст запроса
//	
// Возвращаемое значение:
//  Структура - Структура полей запроса
//
Функция ПолучитьСтруктуруПолейЗапроса(ТекстЗапроса) Экспорт
	
	СтруктураПолейЗапроса = Новый Структура;
	
	Если ТекстЗапроса = "" тогда
		Возврат СтруктураПолейЗапроса;
	КонецЕсли;
	
	СхемаЗапроса = Новый СхемаЗапроса;
	
	Попытка
		СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
	Исключение
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		MultiPort_ШлюзБСПКлиентСервер.СообщитьПользователю(ТекстОшибки); 
		Возврат СтруктураПолейЗапроса;
	КонецПопытки;
	
	ПакетыСхемыЗапроса = СхемаЗапроса.ПакетЗапросов;
	
	ПерваяТаблица = Истина;
	
	НомерТаблиц = 1;
	
	Для каждого ПакетСхемыЗапроса из ПакетыСхемыЗапроса цикл
		
		Если ЗначениеЗаполнено(ПакетСхемыЗапроса.ТаблицаДляПомещения) тогда
			Продолжить;
		КонецЕсли;
		
		Если ПерваяТаблица тогда
			
			Для каждого Колонка из ПакетСхемыЗапроса.Колонки цикл
				СтруктураПолейЗапроса.Вставить(Колонка.Псевдоним);
			КонецЦикла;
			
			ПерваяТаблица = Ложь;
			
			Продолжить;
			
		КонецЕсли;
		
		СтруктураТЗ = Новый Структура;
		
		Для каждого Колонка из ПакетСхемыЗапроса.Колонки цикл
			СтруктураТЗ.Вставить(Колонка.Псевдоним);
		КонецЦикла;
		
		СтруктураПолейЗапроса.Вставить("ТаблицаЗначений" + Строка(НомерТаблиц), СтруктураТЗ);
		НомерТаблиц = НомерТаблиц + 1;
		
	КонецЦикла;
	
	Возврат СтруктураПолейЗапроса;
	
КонецФункции

// Функция получает структуру реквизитов и таблиц на основе типа объекта
//
// Параметры:
//	ТипОбъектаСистемы - СправочникСсылка.ИдентификаторыОбъектовМетаданных 
//  ИсключитьСтандартныеРеквизиты - Булево 
//
// Возвращаемое значение:
//  Структура - структура полей объекта
//
Функция ПолучитьСтруктуруПолейОбъектаСистемыПоТипу(ТипОбъектаСистемы, ИсключитьСтандартныеРеквизиты = Ложь) Экспорт
	
	СтруктураПолейОбъекта = Новый Структура;
	
	Если НЕ ЗначениеЗаполнено(ТипОбъектаСистемы) ИЛИ ТипОбъектаСистемы.ЗначениеПустойСсылки = Неопределено тогда
		Возврат СтруктураПолейОбъекта;
	КонецЕсли;
	
	МетаданныеОбъекта = ТипОбъектаСистемы.ЗначениеПустойСсылки.Метаданные();
	
	Для Каждого Реквизит из МетаданныеОбъекта.Реквизиты цикл
		СтруктураПолейОбъекта.Вставить(Реквизит.Имя, Реквизит.Тип.Типы()[0]);   
	КонецЦикла;
	
	Если НЕ ИсключитьСтандартныеРеквизиты тогда
		Для Каждого Реквизит из МетаданныеОбъекта.СтандартныеРеквизиты цикл
			СтруктураПолейОбъекта.Вставить(Реквизит.Имя);
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТабличнаяЧасть из МетаданныеОбъекта.ТабличныеЧасти цикл
		
		СтруктураТЗ = Новый Структура;
		
		Для Каждого Реквизит из ТабличнаяЧасть.Реквизиты цикл
			СтруктураТЗ.Вставить(Реквизит.Имя, Реквизит.Тип.Типы()[0]);
		КонецЦикла;
		
		СтруктураПолейОбъекта.Вставить(ТабличнаяЧасть.Имя, СтруктураТЗ);

	КонецЦикла;
	
	Возврат СтруктураПолейОбъекта;
	
КонецФункции

#КонецОбласти // Фабрика

Функция ОсновнаяВерсияСхемИнтеграции() Экспорт
	
	//Возврат ПолучитьФункциональнуюОпцию("MultiPort_ОсновнаяСхемаИнтеграции");
	
КонецФункции

Функция ПреобразоватьТекстАлгоритмаВТекстЗапроса(Текст) Экспорт
	
	Если СтрНачинаетсяС(Текст, "ВЫБРАТЬ") тогда
		Возврат Текст;
	КонецЕсли;
	
	НомерНачалаЗапроса = СтрНайти(Текст, """ВЫБРАТЬ");
	
	Если НомерНачалаЗапроса = 0 тогда
		Возврат "";
	КонецЕсли;
	
	НовыйТекстЗапроса = Сред(Текст, НомерНачалаЗапроса + 1); 
	
	НомерКонцаЗапроса = СтрНайти(НовыйТекстЗапроса, """;");
	
	НовыйТекстЗапроса = Лев(НовыйТекстЗапроса, НомерКонцаЗапроса - 1);
	
	НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, "|", "");
	НовыйТекстЗапроса = СтрЗаменить(НовыйТекстЗапроса, """""", """");
	
	Возврат НовыйТекстЗапроса;
	
КонецФункции

#Область РаботаСРегистрамиСведений

// Параметры:
//   Отбор - Отбор - произвольный отбор.
//   КлючЭлемента - Строка - имя элемента отбора.
//   ЗначениеЭлемента - Произвольный - значение элемента отбора.
// 
Процедура УстановитьЗначениеЭлементаОтбора(Отбор, КлючЭлемента, ЗначениеЭлемента) Экспорт

	ЭлементОтбора = Отбор.Найти(КлючЭлемента);
	Если ЭлементОтбора <> Неопределено Тогда
		ЭлементОтбора.Установить(ЗначениеЭлемента);
	КонецЕсли;

КонецПроцедуры

// Добавляет одну запись в регистр сведений по переданным значениям структуры.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура, по значениям которой необходимо создать набор записей и заполнить этот
//                                набор.
//  ИмяРегистра     - Строка - имя регистра сведений, в который необходимо добавить запись.
//   Загрузка		- Булево - режим обмена данными
// 
Процедура ДобавитьЗаписьВРегистрСведений(СтруктураЗаписи, Знач ИмяРегистра, Загрузка = Ложь) Экспорт

	НаборЗаписей = СоздатьНаборЗаписейРегистраСведений(СтруктураЗаписи, ИмяРегистра);
	
	// Добавляем только одну запись в новый набор записей.
	НоваяЗапись = НаборЗаписей.Добавить();
	
	// Заполняем значения свойств записи из переданной структуры.
	ЗаполнитьЗначенияСвойств(НоваяЗапись, СтруктураЗаписи);

	НаборЗаписей.ОбменДанными.Загрузка = Загрузка;
	
	// записываем набор записей
	НаборЗаписей.Записать();

КонецПроцедуры

// Обновляет запись в регистр сведений по переданным значениям структуры.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура, по значениям которой необходимо создать менеджер записи и обновить запись.
//  ИмяРегистра     - Строка - имя регистра сведений, в котором необходимо обновить запись.
// 
Процедура ОбновитьЗаписьВРегистрСведений(СтруктураЗаписи, Знач ИмяРегистра) Экспорт

	МетаданныеРегистра = Метаданные.РегистрыСведений[ИмяРегистра]; // ОбъектМетаданныхРегистрСведений
	
	// Создаем менеджер записи регистра.
	МенеджерЗаписи = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
	
	// Устанавливаем отбор по измерениям регистра.
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл

		ИмяИзмерения = Измерение.Имя;
		
		// Если задано значение в структуре, то отбор устанавливаем.
		Если СтруктураЗаписи.Свойство(ИмяИзмерения) Тогда

			МенеджерЗаписи[ИмяИзмерения] = СтруктураЗаписи[ИмяИзмерения];

		КонецЕсли;

	КонецЦикла;
	
	// Считываем запись из базы данных.
	МенеджерЗаписи.Прочитать();
	
	// Заполняем значения свойств записи из переданной структуры.
	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СтруктураЗаписи);
	
	// записываем менеджер записи
	МенеджерЗаписи.Записать();

КонецПроцедуры

// Удаляет набор записей в регистре по переданным значениям структуры.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура, по значениям которой необходимо удалить набор записей.
//  ИмяРегистра     - Строка - имя регистра сведений, в котором необходимо удалить набор записей.
//  Загрузка		- Булево - режим обмена данными
// 
Процедура УдалитьНаборЗаписейВРегистреСведений(СтруктураЗаписи, ИмяРегистра, Загрузка = Ложь) Экспорт

	НаборЗаписей = СоздатьНаборЗаписейРегистраСведений(СтруктураЗаписи, ИмяРегистра);

	НаборЗаписей.ОбменДанными.Загрузка = Загрузка;
	
	// записываем набор записей
	НаборЗаписей.Записать();

КонецПроцедуры

// Создает набор записей регистра сведений по переданным значениям структуры. Добавляет одну запись в набор.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура по значениям которой необходимо создать набор записей и заполнить этот
//                                набор.
//  ИмяРегистра     - Строка - имя регистра сведений.
//  
// Возвращаемое значение:
//   РегистрСведенийНаборЗаписей - набор записей регистра по указанному отбору.
// 
Функция СоздатьНаборЗаписейРегистраСведений(СтруктураЗаписи, ИмяРегистра) Экспорт

	НаборЗаписей = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей(); // РегистрСведенийНаборЗаписей
	
	// Устанавливаем отбор по измерениям регистра.
	Для Каждого КлючЗначение Из СтруктураЗаписи Цикл
		УстановитьЗначениеЭлементаОтбора(НаборЗаписей.Отбор, КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;

	Возврат НаборЗаписей;

КонецФункции

#КонецОбласти

// Будет ли выброшено исключение "В данной транзакции уже происходили ошибки" (является ли транзакция сломанной)
// from TormozIT
// 
// Возвращаемое значение:
//  Булево - Если были ошибки, то Истина
//
Функция ВТранзакцииПроисходилиОшибки() Экспорт 
	
	Запрос = Новый Запрос("ВЫБРАТЬ 1"); // Обращения к серверу СУБД этот запрос не производит (только к модели БД)
	Попытка
		Запрос.Выполнить();
		Результат = Ложь;
	Исключение
		Результат = Истина;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Помещение представления ссылки в кэш представлений в сломанной транзакции вызывает досрочное завершение
//  фактической транзакции с невосстановимой ошибкой "В данной транзакции уже происходили ошибки".
//  Передача в метод ЗаписьЖурналаРегистрации() ссылки на объект в сломанной транзакции приведет к такому
//  исключению, если представление будет обновлено в кэше.
//  Поэтому в таком случае функция возвращает строку идентификатор ссылки.   
//  from TormozIT
//
// Параметры:
//  СсылкаДляЛогаЖР	 - ЛюбаяСсылка - 
// 
// Возвращаемое значение:
//  Строка - представление ссылки для безопасной записи в журнал регистрации
//
Функция СсылкаДляПередачиВЖурналРегистрации(СсылкаДляЛогаЖР) Экспорт 
	
	Если ВТранзакцииПроисходилиОшибки() Тогда
		Результат = "" + СсылкаДляЛогаЖР.УникальныйИдентификатор();
	Иначе
		Результат = СсылкаДляЛогаЖР; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу.
//
// Параметры:
//  ПроверяемыйОбъект - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект ссылочного типа.
//
Функция ЭтоОбъектСсылочногоТипа(ПроверяемыйОбъект) Экспорт
	
	Если ТипЗнч(ПроверяемыйОбъект) = Тип("ОбъектМетаданных") Тогда
		ИмяОбъектаМетаданных = ПроверяемыйОбъект.ПолноеИмя();
		Позиция = СтрНайти(ИмяОбъектаМетаданных, ".");
		Если Позиция > 0 Тогда 
			ИмяБазовогоТипа = Лев(ИмяОбъектаМетаданных, Позиция - 1);
			Возврат ИмяБазовогоТипа = "Справочник"
			Или ИмяБазовогоТипа = "Документ"
			Или ИмяБазовогоТипа = "БизнесПроцесс"
			Или ИмяБазовогоТипа = "Задача"
			Или ИмяБазовогоТипа = "ПланСчетов"
			Или ИмяБазовогоТипа = "ПланОбмена"
			Или ИмяБазовогоТипа = "ПланВидовХарактеристик"
			Или ИмяБазовогоТипа = "ПланВидовРасчета";
		Иначе
			Возврат Ложь;
		КонецЕсли;		
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Получить представление информационной базы для отображения пользователю.
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
// 
// Возвращаемое значение:
//   Строка      - Представление информационной базы
//
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();
	
	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		ПутьКБД = Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	Иначе
		// надо к имени сервера прибавить имя пути информационной базы
		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
		НачальнаяПозицияКопирования = 6 + 1;
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
		
		// позиция имени сервера
		ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
		
		Если ПозицияПоиска <> 1 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		НачальнаяПозицияКопирования = 6;
		ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
		КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
		
		ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
		
		ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;
		
	КонецЕсли;
	
	Возврат ПутьКБД;
	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

Функция ПриНачалеВыполненияРегламентногоЗадания(РеглЗадание, ИДРеглЗадания, ВнешняяСистема = Неопределено) Экспорт
	
	ИмяРеглЗадания = РеглЗадание.Имя;
		
	Если Не MultiPort_Обмен.РазрешенаРаботаПодсистемыОбмена(ИДРеглЗадания, ИмяРеглЗадания) Тогда
		ТекстОшибки = "Работа адаптера не разблокирована. (см. также ЖР событие ""КонтрольРеглЗаданийАдаптера"")
						|Для включения необходимо воспользовать командой "
						+ """Блокировка обмена (MultiPort)"" в общем интерфейсе или интерфейсе администратора";
		MultiPort_ВызовСервера.ВыполнитьЛогирование("Операции адаптера заблокированы",
						УровеньЖурналаРегистрации.Информация, ТекстОшибки,
						ВнешняяСистема, Истина);
		Возврат Ложь;
	КонецЕсли;
	
	Если РегламентноеЗаданиеЗапущено(ИДРеглЗадания) Тогда
		ТекстОшибки = СтрШаблон("Регламентное задание %1 уже выполняется. 
								|Повторный запуск возможен после завершения текущего.", ИмяРеглЗадания);						
		MultiPort_ВызовСервера.ВыполнитьЛогирование("Операции адаптера заблокированы",
						УровеньЖурналаРегистрации.Информация, ТекстОшибки,
						ВнешняяСистема, Истина);
		Возврат Ложь;  
	КонецЕсли; 	
	
	MultiPort_ШлюзБСПСервер.ПриНачалеВыполненияРегламентногоЗадания(РеглЗадание);
	
	Возврат Истина;
	
КонецФункции	

// Определяет запущено ли регламентное задание
//
// Параметры:
//  ИДРеглЗадания	 - 	Строка - Имя объекта конфигурации
// 
// Возвращаемое значение:
//  Булево - Если рег. задание выполняется вернется истина, иначе ложь
//
Функция РегламентноеЗаданиеЗапущено(ИДРеглЗадания) Экспорт 
	
	РеглЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(ИДРеглЗадания);
	 	
	Если РеглЗадание <> Неопределено Тогда
		Отбор = Новый Структура("РегламентноеЗадание, Состояние, КлючФоновогоЗадания");
		Отбор.РегламентноеЗадание = РеглЗадание;
		Отбор.Состояние = СостояниеФоновогоЗадания.Активно;		
		ИсполняющиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
		
		// Если есть активные фоновые задания - выходим 
		Возврат ИсполняющиеФоновыеЗадания.Количество() > 1;
	КонецЕсли;	
	
	Возврат Ложь;
	
КонецФункции

// Функция возвращает текст xml полученный из исходного текста xml из которого
//  удалены недопустимые символы
//
// Параметры:
//  ТекстXML - Строка - текст в формате xml
// 
// Возвращаемое значение:
//  Строка - текст в формате xml без недопустимых символов
//
Функция УдалитьНедопустимыеСимволыXML(Знач ТекстXML) Экспорт

    Позиция = НайтиНедопустимыеСимволыXML(ТекстXML, , );

	Пока Позиция <> 0 Цикл
		ТекстXML = Лев(ТекстXML, Позиция - 1) + Сред(ТекстXML, Позиция + 1);
		Позиция = НайтиНедопустимыеСимволыXML(ТекстXML, , );
	КонецЦикла;

	ДлинаТекстаXML = СтрДлина(ТекстXML);
	МассивНекорректныхСимволов = Новый Массив;
	
	Для Сч = 1 По ДлинаТекстаXML Цикл 
		Символ = Сред(ТекстXML,Сч,1);
		КодСимвола = КодСимвола(Символ);
		Если (КодСимвола >= 32 И КодСимвола <= 126)         // Символы цифры и латиница  https://en.wikipedia.org/wiki/ISO/IEC_8859-5
			ИЛИ (КодСимвола >= 1025 И КодСимвола <= 1119) 	// Ёё Кирилица и другие
			ИЛИ КодСимвола = 9 		// табуляция
			ИЛИ КодСимвола = 10 	// Перенос строки
			ИЛИ КодСимвола = 8470 	// №
			ИЛИ КодСимвола = 167 	// §
			Тогда
			
			Продолжить;
		Иначе
			Если МассивНекорректныхСимволов.Найти(КодСимвола) = Неопределено Тогда
				МассивНекорректныхСимволов.Добавить(КодСимвола);
			КонецЕсли;
		КонецЕсли;		
	КонецЦикла;	
	
	Для Каждого НекорректныйКодСимвола Из МассивНекорректныхСимволов Цикл
		Если НекорректныйКодСимвола = 8211	//	дефис
			Тогда
			ТекстXML = СтрЗаменить(ТекстXML, Символ(НекорректныйКодСимвола), "-"); // производится замена символа дефис на -
		Иначе	
			ТекстXML = СтрЗаменить(ТекстXML, Символ(НекорректныйКодСимвола), " "); //заменяем на пробел
		КонецЕсли;	
	КонецЦикла;	
		
	ТекстXML = СтрЗаменить(ТекстXML, Символ(171), """"); // производится замена символа « на "
	ТекстXML = СтрЗаменить(ТекстXML, Символ(187), """"); // производится замена символа » на "
	ТекстXML = СтрЗаменить(ТекстXML, Символ(8222), """"); // производится замена символа „ на "
	ТекстXML = СтрЗаменить(ТекстXML, Символ(8220), """"); // производится замена символа “ на "
	                	 	
	Возврат ТекстXML;

КонецФункции //УдалитьНедопустимыеСимволыXML()

// Преобразовывает двоичные данные в формат base64
//
// Параметры:
//  ТекстовыеДанные - Строка
//  СжиматьВZip		- Булево 
//  ТипДанных		- Строка - Если передано "Base64Значение" то преобразования не будет
//
// Возвращаемое значение:
//   Строка - строка двоичных данных в формате base64
//
Функция ДанныеВСтрокуBase64(ТекстовыеДанные, СжиматьВZip = Ложь, ТипДанных = "") Экспорт 
  
	Если Не ЗначениеЗаполнено(ТекстовыеДанные) Тогда 
		Возврат Неопределено;
	КонецЕсли; 	
		
	Если СжиматьВZip Тогда
		
		ИмяВременногоФайла  = ПолучитьИмяВременногоФайла();		
		ЗаписьТекста = Новый ЗаписьТекста(ИмяВременногоФайла);
		ЗаписьТекста.Записать(ТекстовыеДанные);
		ЗаписьТекста.Закрыть();
	
		НовыйАрхивИмя 	= ПолучитьИмяВременногоФайла();
		НовыйАрхив 		= Новый ЗаписьZIPФайла(НовыйАрхивИмя, , , МетодСжатияZIP.Сжатие);
		НовыйАрхив.Добавить(ИмяВременногоФайла, РежимСохраненияПутейZIP.НеСохранятьПути);
		ДанныеАрхива 	= Новый ДвоичныеДанные(НовыйАрхивИмя);
		вBase64 		= Base64Строка(ДанныеАрхива);
		
		УдалитьФайлы(ИмяВременногоФайла);
		УдалитьФайлы(НовыйАрхивИмя);
	Иначе
		Если ТипДанных = "Base64Значение" Тогда 		
			вBase64 = ТекстовыеДанные;
        Иначе
			ДвоичныеДанныеСтроки = ПолучитьДвоичныеДанныеИзСтроки(ТекстовыеДанные);
			вBase64 = Base64Строка(ДвоичныеДанныеСтроки);		
		КонецЕсли;	
	КонецЕсли;
	
	//Убираем пробелы и символы переноса строки;
	вBase64 = СтрЗаменить(СтрЗаменить(вBase64, Символ(10), ""), Символ(13), "");
		
	Возврат вBase64;
		
КонецФункции

// Получение разрешений на интернет ресурс. Используется при подключении обработок в безопасном режиме
// для заполнения массива разрешений - Массив из ОбъектXDTO.
// Получает необходимые параметры из карточки справочника MultiPort_ПодключенияКВнешнимСистемам.  
//
// Параметры:
//
//  ИдентификаторПодключения - Строка - Идентификатор карточки справочника MultiPort_ПодключенияКВнешнимСистемам.
//  ИнтерфейсПодключения	 - Строка - Для определения типа параметров. Допустимые значения: http, web.
//  Описание				 - Строка - описание причины, по которой требуется предоставление разрешения.
//
// Возвращаемое значение:
//   Структура - структура полей для разрешений на интернет ресурсы
//
Функция ПолучитьРазрешенияНаИнтернетРесурс(ИдентификаторПодключения, ИнтерфейсПодключения, Описание) Экспорт
	
	ДляСервисаHTTP = "http";
	ДляСервисаWeb = "web";  
	
	СтруктураРазрешений = Новый Структура();
	СтруктураРазрешений.Вставить("Протокол", "");
	СтруктураРазрешений.Вставить("Порт", 0);
	СтруктураРазрешений.Вставить("АдресРесурса", "");
	СтруктураРазрешений.Вставить("Описание", "");
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ИдентификаторПодключения", ИдентификаторПодключения);
		
	Если ИнтерфейсПодключения = ДляСервисаHTTP Тогда
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	MultiPort_ПодключенияКВнешнимСистемам.HTTPАдресСервиса КАК АдресСервиса,
		|	MultiPort_ПодключенияКВнешнимСистемам.HTTPРесурсНаСервере КАК РесурсНаСервере,
		|	MultiPort_ПодключенияКВнешнимСистемам.HTTPПорт КАК Порт,
		|	ВЫБОР
		|		КОГДА MultiPort_ПодключенияКВнешнимСистемам.HTTPЗащищенноеСоединение
		|			ТОГДА ""HTTPS""
		|		ИНАЧЕ ""HTTP""
		|	КОНЕЦ КАК Протокол,
		|	ВЫБОР
		|		КОГДА ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.HTTPАдресСервиса, 1, 4) <> ""http""
		|				И ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.HTTPАдресСервиса, 1, 4) <> """"
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ КАК АдресКорректный
		|ИЗ
		|	Справочник.MultiPort_ПодключенияКВнешнимСистемам КАК MultiPort_ПодключенияКВнешнимСистемам
		|ГДЕ
		|	MultiPort_ПодключенияКВнешнимСистемам.ИдентификаторПодключения = &ИдентификаторПодключения";
				
	ИначеЕсли ИнтерфейсПодключения = ДляСервисаWeb Тогда
		Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL КАК WSСсылкаWSDL,
		|	ВЫБОР
		|		КОГДА ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL, 1, 5) = ""https""
		|			ТОГДА ""HTTPS""
		|		КОГДА ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL, 1, 4) = ""http""
		|			ТОГДА ""HTTP""
		|		ИНАЧЕ ""Не корректная ссылка WSDL в параметрах подключения "" + (ВЫРАЗИТЬ(&ИдентификаторПодключения КАК СТРОКА(100)))
		|	КОНЕЦ КАК Протокол,
		|	MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL КАК АдресСервиса,
		|	ВЫБОР
		|		КОГДА ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL, 1, 5) = ""https""
		|			ТОГДА 9
		|		КОГДА ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL, 1, 4) = ""http""
		|			ТОГДА 8
		|		ИНАЧЕ 8
		|	КОНЕЦ КАК НачалоАдресаWS, 	
		|	НЕОПРЕДЕЛЕНО КАК Порт,
		|	ВЫБОР
		|		КОГДА ПОДСТРОКА(MultiPort_ПодключенияКВнешнимСистемам.WSСсылкаWSDL, 1, 4) = ""http""
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ КАК АдресКорректный
		|ИЗ
		|	Справочник.MultiPort_ПодключенияКВнешнимСистемам КАК MultiPort_ПодключенияКВнешнимСистемам
		|ГДЕ
		|	MultiPort_ПодключенияКВнешнимСистемам.ИдентификаторПодключения = &ИдентификаторПодключения"; 
		
	Иначе
		MultiPort_ШлюзБСПКлиентСервер.СообщитьПользователю("Не определен интерфейс транспорта: http-сервис или web-сервис");
		Возврат СтруктураРазрешений;
	КонецЕсли;
	
	РезультатЗапроса = Запрос.Выполнить();
	Выборка = РезультатЗапроса.Выбрать();
	Если Выборка.Следующий() Тогда
		
		Протокол = Выборка.Протокол;						
		Порт = Выборка.Порт;
		
		Если Не Выборка.АдресКорректный Тогда
			ТекстСообщения = "Не корректно задан адрес сервиса " + ИнтерфейсПодключения + " в параметрах подключения - " 
			+ ИдентификаторПодключения;
			MultiPort_ШлюзБСПКлиентСервер.СообщитьПользователю(ТекстСообщения);
			Возврат СтруктураРазрешений;
		КонецЕсли;
			
		Если ИнтерфейсПодключения = ДляСервисаHTTP Тогда
						
			АдресРесурса = Выборка.АдресСервиса + Выборка.РесурсНаСервере;
			
		ИначеЕсли ИнтерфейсПодключения = ДляСервисаWeb Тогда
						
			СсылкаWSDL = Выборка.WSСсылкаWSDL; 		
			ПозицияКонцаРесурса = СтрНайти(СсылкаWSDL, "/", НаправлениеПоиска.СКонца); 			
			АдресРесурса = Сред(СсылкаWSDL, Выборка.НачалоАдресаWS, ПозицияКонцаРесурса - Выборка.НачалоАдресаWS);
						
		Иначе
			MultiPort_ШлюзБСПКлиентСервер.СообщитьПользователю("Не определен интерфейс транспорта: http-сервис или web-сервис");
			Возврат СтруктураРазрешений;
			
		КонецЕсли;
	Иначе
		ТекстСообщения = "Не найдено подключение по идентификатору - " + ИдентификаторПодключения;
		MultiPort_ШлюзБСПКлиентСервер.СообщитьПользователю(ТекстСообщения);
		Возврат СтруктураРазрешений;			
	КонецЕсли;
	
	ДополненноеОписание = СтрШаблон("%1 (%2)", Описание, ИнтерфейсПодключения);
				
	СтруктураРазрешений.Протокол = Протокол;
	СтруктураРазрешений.Порт = Порт;
	СтруктураРазрешений.АдресРесурса = АдресРесурса;
	СтруктураРазрешений.Описание = ДополненноеОписание;
			
	Возврат СтруктураРазрешений;		
	
КонецФункции

#КонецОбласти