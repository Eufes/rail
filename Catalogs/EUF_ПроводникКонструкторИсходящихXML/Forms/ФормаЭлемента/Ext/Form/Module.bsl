
#Область ОбработчикиСобытийФормы

&НаСервере
Процедура ПередЗаписьюНаСервере(Отказ, ТекущийОбъект, ПараметрыЗаписи)
	
	ОбДерево = ДанныеФормыВЗначение(ДеревоПолейСообщения, Тип("ДеревоЗначений"));
	
	//Проверки заполенния дерева и реквизитов
	//EUF_ПроводникКонструкторСообщенийXML.ПроверитьЗаполнениеДереваСтруктураПолей(ОбДерево, Отказ);
	
    ТекущийОбъект.ХранилищеДерева = Новый ХранилищеЗначения(ОбДерево);

КонецПроцедуры

&НаСервере
Процедура ПриЧтенииНаСервере(ТекущийОбъект)
	
	ДеревоИзХранилища = ТекущийОбъект.ХранилищеДерева.Получить();
	Если ДеревоИзХранилища <> Неопределено И ТипЗнч(ДеревоИзХранилища) = Тип("ДеревоЗначений") Тогда
		// Выполняем в попытке для случая изменения состава колонок на форме
		Попытка
			ЗначениеВДанныеФормы(ТекущийОбъект.ХранилищеДерева.Получить(), ДеревоПолейСообщения);
		Исключение
			// Обходим дерево
			ОбДерево = ДанныеФормыВЗначение(ДеревоПолейСообщения, Тип("ДеревоЗначений"));			
			ЗаполнитьСтрокиДереваФормыИзДереваХранилища(ДеревоИзХранилища.Строки, ОбДерево.Строки);
			ЗначениеВДанныеФормы(ОбДерево, ДеревоПолейСообщения);
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	//Если ЗначениеЗаполнено(Объект.ВерсияСхемы) тогда
	//	
	//	ФабрикаXDTOВерсии = EUF_ПроводникПовтИсп.ПолучитьФабрикуXDTOПоВерсииСхемИнтеграции(Объект.ВерсияСхемы);
	//
	//	ЭтотОбъект.Элементы.URIПространстваИменПакета.СписокВыбора.Очистить();
	//	
	//	ПакетыСхемы = ФабрикаXDTOВерсии.Пакеты;
	//		
	//	Для каждого Пакет из ПакетыСхемы цикл
	//		ЭтотОбъект.Элементы.URIПространстваИменПакета.СписокВыбора.Добавить(Пакет.URIПространстваИмен);
	//	КонецЦикла;	
	//	
	//	ЭтотОбъект.Элементы.URIПространстваИменПакета.СписокВыбора.СортироватьПоЗначению();
	//	
	//КонецЕсли;
	
	//Если ЗначениеЗаполнено(Объект.URIПространстваИменПакета) И ЗначениеЗаполнено(Объект.ВерсияСхемы) тогда
	//	
	//	ПакетыТипов = ПолучитьПакетыТиповСхемыXSD(Объект.ВерсияСхемы, Объект.URIПространстваИменПакета);
	//	
	//	ЭтотОбъект.Элементы.КорневойУзел.СписокВыбора.Очистить();
	//	
	//	//Если ПакетыТипов.Количество() тогда
	//		Для каждого Пакет из ПакетыТипов цикл
	//			ЭтотОбъект.Элементы.КорневойУзел.СписокВыбора.Добавить(Пакет.Имя);
	//		КонецЦикла;
	//	//Иначе
	//		Для каждого Пакет из ПакетыТипов.КорневыеСвойства цикл
	//			ЭтотОбъект.Элементы.КорневойУзел.СписокВыбора.Добавить(Пакет.Имя);
	//		КонецЦикла;
	//	//КонецЕсли;
	//	
	//КонецЕсли;
	
	ЗаполнитьСписокВыбораЗначенийПолейДерева();
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработкаВыбора(ВыбранноеЗначение, ИсточникВыбора)
	
	Если ИсточникВыбора.ИмяФормы = "Справочник.EUF_ПроводникКонструкторИсходящихXML.Форма.ФормаРедактированияСтроки" Тогда
		ОбработкаИзмененияСтроки(ВыбранноеЗначение);
	ИначеЕсли ИсточникВыбора.ИмяФормы = "Справочник.EUF_ПроводникКонструкторИсходящихXML.Форма.ФормаВыбора" Тогда
		Если ЗначениеЗаполнено(ВыбранноеЗначение) Тогда			
			ЗаполнитьДеревоИзДругогоПравила(ВыбранноеЗначение);					
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	УправлениеФормой();
	
КонецПроцедуры

&НаКлиенте
Процедура УправлениеФормой()
	
	Элементы.ОткрытьКонструкторЗапроса.Доступность 										 = НЕ Объект.ДанныеПолучатьВыполняемымАлгоритмом;
	Элементы.АлгоритмПолученияДанныхКонтекстноеМенюОткрытьКонструкторЗапроса.Доступность = НЕ Объект.ДанныеПолучатьВыполняемымАлгоритмом;
	Элементы.ПроверитьЗапрос.Доступность 										 = НЕ Объект.ДанныеПолучатьВыполняемымАлгоритмом;

КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийПолейФормы

&НаСервере
Процедура ВерсияСхемыПриИзмененииНаСервере()
	
	ФабрикаXDTOВерсии = EUF_ПроводникПовтИсп.ПолучитьФабрикуXDTOПоВерсииСхемИнтеграции(Объект.ВерсияСхемы);
	
	ЭтотОбъект.Элементы.URIПространстваИменПакета.СписокВыбора.Очистить();
	
	ПакетыСхемы = ФабрикаXDTOВерсии.Пакеты;
		
	Для каждого Пакет из ПакетыСхемы цикл
		ЭтотОбъект.Элементы.URIПространстваИменПакета.СписокВыбора.Добавить(Пакет.URIПространстваИмен);
		
	КонецЦикла;	
	
	ЭтотОбъект.Элементы.URIПространстваИменПакета.СписокВыбора.СортироватьПоЗначению();
	
КонецПроцедуры

&НаКлиенте
Процедура ВерсияСхемыПриИзменении(Элемент)
	ВерсияСхемыПриИзмененииНаСервере();
КонецПроцедуры

&НаСервере
Процедура URIПространстваИменПакетаПриИзмененииНаСервере()
	
	Объект.КорневойУзел = "";
	
	ЭтотОбъект.Элементы.КорневойУзел.СписокВыбора.Очистить();
	
	Если ЗначениеЗаполнено(Объект.URIПространстваИменПакета) И ЗначениеЗаполнено(Объект.ВерсияСхемы) тогда
		
		ПакетыТипов = ПолучитьПакетыТиповСхемыXSD(Объект.ВерсияСхемы, Объект.URIПространстваИменПакета);
		
		//Если ПакетыТипов.Количество() тогда
			Для каждого Пакет из ПакетыТипов цикл
				ЭтотОбъект.Элементы.КорневойУзел.СписокВыбора.Добавить(Пакет.Имя);
			КонецЦикла;
		//Иначе
			Для каждого Пакет из ПакетыТипов.КорневыеСвойства цикл
				ЭтотОбъект.Элементы.КорневойУзел.СписокВыбора.Добавить(Пакет.Имя);
			КонецЦикла;
		//КонецЕсли;
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура URIПространстваИменПакетаПриИзменении(Элемент)
	URIПространстваИменПакетаПриИзмененииНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ДеревоПолейСообщенияЭлементТаблицыПриИзменении(Элемент)
	
	ТекущаяСтрокаДерева = Элементы.ДеревоПолейСообщения.ТекущиеДанные;
	
	Если ТекущаяСтрокаДерева = Неопределено тогда
		Возврат;
	КонецЕсли;
	
	ИДСтроки = ТекущаяСтрокаДерева.ПолучитьИдентификатор();
	ДеревоПолейСообщенияЭлементТаблицыПриИзмененииНаСервере(ИДСтроки);
	
КонецПроцедуры

&НаСервере
Процедура ДеревоПолейСообщенияЭлементТаблицыПриИзмененииНаСервере(ИДСтроки)
	
	ТекущийЭлементДерева = ЭтотОбъект.ДеревоПолейСообщения.НайтиПоИдентификатору(ИДСтроки); 
	
	Если ТекущийЭлементДерева = Неопределено тогда
		Возврат;
	КонецЕсли;

	ЗначениеЭлементТаблицы = ТекущийЭлементДерева.ЭлементТаблицы;
	
	ЗаполнитьРекурсивноЗначениеПоляЭлементТаблицыУПодчиненныхСтрок(ТекущийЭлементДерева, ЗначениеЭлементТаблицы);
	
КонецПроцедуры

&НаСервере
Процедура ДанныеПолучатьВыполняемымАлгоритмомПриИзмененииНаСервере()
	
	Если Объект.ДанныеПолучатьВыполняемымАлгоритмом тогда
		Объект.АлгоритмПолученияДанных = СформироватьТекстЗапросаДляКонфигуратора(Объект.АлгоритмПолученияДанных); 	
	Иначе
		Объект.АлгоритмПолученияДанных = EUF_ПроводникОбщегоНазначения.ПреобразоватьТекстАлгоритмаВТекстЗапроса(Объект.АлгоритмПолученияДанных);
	КонецЕсли;
	
	АлгоритмПолученияДанныхПриИзмененииНаСервере();
	
КонецПроцедуры

&НаКлиенте
Процедура ДанныеПолучатьВыполняемымАлгоритмомПриИзменении(Элемент)
	
	ДанныеПолучатьВыполняемымАлгоритмомПриИзмененииНаСервере();
	УправлениеФормой();
	
КонецПроцедуры

&НаКлиенте
Процедура ДеревоПолейФормулаТегаНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ОткрытьФормуРедактированияСтроки(Элементы.ДеревоПолейСообщения.ТекущаяСтрока);
	
КонецПроцедуры

&НаСервере
Процедура АлгоритмПолученияДанныхПриИзмененииНаСервере()
	ЗаполнитьСписокВыбораЗначенийПолейДерева();
КонецПроцедуры

&НаКлиенте
Процедура АлгоритмПолученияДанныхПриИзменении(Элемент)
	АлгоритмПолученияДанныхПриИзмененииНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ДеревоПолейСообщенияПриИзменении(Элемент)
	
	Модифицированность = Истина;
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиКомандФормы

&НаСервере
Процедура ЗаполнитьДеревоИзДругогоПравила(ВыбранноеЗначение)

	ДеревоДругогоПравила = ВыбранноеЗначение.ХранилищеДерева.Получить();
		
	Попытка
		ЗначениеВДанныеФормы(ДеревоДругогоПравила, ДеревоПолейСообщения);
	Исключение		
		ОбДерево = ДанныеФормыВЗначение(ДеревоПолейСообщения, Тип("ДеревоЗначений"));			
		ЗаполнитьСтрокиДереваФормыИзДереваХранилища(ДеревоДругогоПравила.Строки, ОбДерево.Строки);
		ЗначениеВДанныеФормы(ОбДерево, ДеревоПолейСообщения);
	КонецПопытки;
	
КонецПроцедуры

&НаСервере
Процедура ЗаполнитьСтруктуруПолейНаСервере()
	
	Если НЕ ЗначениеЗаполнено(Объект.КорневойУзел) тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ (ЗначениеЗаполнено(Объект.URIПространстваИменПакета) И ЗначениеЗаполнено(Объект.ВерсияСхемы)) тогда
		Возврат;
	КонецЕсли;
	
	СтруктураСхем = EUF_ПроводникПовтИсп.ПолучитьФабрикуXDTOиНаборСхемПоВерсииСхемИнтеграции(Объект.ВерсияСхемы);		
	
	Если СтруктураСхем.ФабрикаXDTO = Неопределено тогда
		Возврат;
	КонецЕсли;
	
	Пакет = СтруктураСхем.ФабрикаXDTO.Пакеты.Получить(Объект.URIПространстваИменПакета);
	
	ТипПакета = Пакет.Получить(Объект.КорневойУзел);
	
	Если ТипПакета = Неопределено тогда
		ТипПакета = Пакет.КорневыеСвойства.Получить(Объект.КорневойУзел);	
	КонецЕсли;
	
	Если ТипПакета = Неопределено тогда
		Возврат;
	КонецЕсли;
	
	НаборСхемXML	= СтруктураСхем.НаборСхемXML;
	СписокУзловDOM	= Неопределено;
	
	Если СтруктураСхем.НаборСхемXML <> Неопределено тогда
		
		СхемаXML 		= НаборСхемXML.Получить(Объект.URIПространстваИменПакета);
		ОпределениеXML 	= СхемаXML.ОпределенияТипов.Получить(Объект.КорневойУзел);
		
		Если ОпределениеXML <> Неопределено тогда
			Попытка
				СписокУзловDOM 	= ОпределениеXML.ЭлементDOM.ДочерниеУзлы[1].ДочерниеУзлы;
			Исключение
			КонецПопытки;
		КонецЕсли;
		
	КонецЕсли;

	ДеревоСвойств = Новый ДеревоЗначений;
	
	ДеревоСвойств.Колонки.Добавить("Поле");
	ДеревоСвойств.Колонки.Добавить("ПространствоИмен");
	ДеревоСвойств.Колонки.Добавить("ИмяТипа");
	ДеревоСвойств.Колонки.Добавить("ФормулаТега");
	ДеревоСвойств.Колонки.Добавить("Комментарий");
	ДеревоСвойств.Колонки.Добавить("НеВыгружать");
	ДеревоСвойств.Колонки.Добавить("Обязательное");
	ДеревоСвойств.Колонки.Добавить("ЭлементТаблицы");
	
	МассивРаскрытыхТипов = Новый Массив;
	МассивРаскрытыхТипов.Добавить(ТипПакета.Имя);
	
	ЗаполнитьДеревоПолейПоТипуСПояснениямиРекурсивно(ДеревоСвойств, ТипПакета, НаборСхемXML, СписокУзловDOM, МассивРаскрытыхТипов);
	
	ЗначениеВРеквизитФормы(ДеревоСвойств, "ДеревоПолейСообщения");	
	
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьСтруктуруПолей(Команда)
	
	ДанныеФормыДерево = ЭтаФорма.ДеревоПолейСообщения.ПолучитьЭлементы();
	
	Если ДанныеФормыДерево.Количество() тогда
	
		ТекстВопроса = "При заполнении существующее дерево будет очищено. Продолжить?";
		
		ПоказатьВопрос(Новый ОписаниеОповещения("ЗаполнитьСтруктуруПолейЗавершение", ЭтотОбъект), ТекстВопроса, РежимДиалогаВопрос.ДаНет);
		
	Иначе
	
		ЗаполнитьСтруктуруПолейНаСервере();
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьСтруктуруПолейЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт
	
	Ответ = РезультатВопроса;
	Если Ответ = КодВозвратаДиалога.Нет Тогда
		Возврат;
	КонецЕсли;	
	
	ЗаполнитьСтруктуруПолейНаСервере();
	
КонецПроцедуры

&НаСервере
Процедура СкопироватьСтрокуВДеревеРекурсивно(Источник, Приемник)
	
	ЗаполнитьЗначенияСвойств(Приемник, Источник);
	
	СтрокиДляКопирования = ПолучитьСписокСтрокДереваДляКопирования(Источник);
	
	Для Каждого Стр Из СтрокиДляКопирования Цикл 
		НовСтр = Приемник.ПолучитьЭлементы().Добавить();
		СкопироватьСтрокуВДеревеРекурсивно(Стр, НовСтр);
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура СкопироватьСтрокуДереваПолейНаСервере(ИДСтроки)
	
	ТекущийЭлементДерева = ЭтотОбъект.ДеревоПолейСообщения.НайтиПоИдентификатору(ИДСтроки); 
	
	Если ТекущийЭлементДерева = Неопределено тогда
		Возврат;
	КонецЕсли;

	Родитель = ТекущийЭлементДерева.ПолучитьРодителя();
	Приемник = Родитель.ПолучитьЭлементы().Добавить();
	СкопироватьСтрокуВДеревеРекурсивно(ТекущийЭлементДерева, Приемник);
	
КонецПроцедуры

&НаКлиенте
Процедура СкопироватьСтрокуДереваПолей(Команда)
	
	ТекущаяСтрокаДерева = Элементы.ДеревоПолейСообщения.ТекущиеДанные;
	
	Если ТекущаяСтрокаДерева = Неопределено тогда
		Возврат;
	КонецЕсли;
	
	ИДСтроки = ТекущаяСтрокаДерева.ПолучитьИдентификатор();
	СкопироватьСтрокуДереваПолейНаСервере(ИДСтроки);
	
КонецПроцедуры

&НаКлиенте
Процедура ОткрытьКонструкторЗапроса(Команда)
	
	ТекстЗапросаВФорме = СокрЛП(Объект.АлгоритмПолученияДанных);
	
	Если ТекстЗапросаВФорме <> "" И НЕ СтрНачинаетсяС(ТекстЗапросаВФорме, "ВЫБРАТЬ") тогда
		Сообщить("Конструктор запроса доступен только для редактирования алгоритма в режиме запроса!");
		Возврат;
	КонецЕсли;
	
	Если ТекстЗапросаВФорме = "" тогда
		КонструкторЗапроса = Новый КонструкторЗапроса;
	Иначе
		КонструкторЗапроса = Новый КонструкторЗапроса(ТекстЗапросаВФорме);
	КОнецЕсли;
	
	Оповещение = Новый ОписаниеОповещения("ПослеЗакрытияКонструктораЗапроса", ЭтотОбъект, Новый Структура);
	КонструкторЗапроса.Показать(Оповещение);

КонецПроцедуры

&НаКлиенте
Процедура ПослеЗакрытияКонструктораЗапроса(ТекстЗапросаВФорме, ДополнитьльныеДанные) Экспорт
	
	Если ТекстЗапросаВФорме <> Неопределено Тогда
		
		Объект.АлгоритмПолученияДанных = ТекстЗапросаВФорме;
		Модифицированность = Истина;
		АлгоритмПолученияДанныхПриИзмененииНаСервере();
		
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте 
Процедура ЗаполнитьДеревоИзПравила(Команда)
	
	ДанныеФормыДерево = ЭтаФорма.ДеревоПолейСообщения.ПолучитьЭлементы();
	
	Если ДанныеФормыДерево.Количество() тогда
	
		ТекстВопроса = "При заполнении существующее дерево будет очищено. Продолжить?";
		
		ПоказатьВопрос(Новый ОписаниеОповещения("ЗаполнитьДеревоИзПравилаЗавершение", ЭтотОбъект), ТекстВопроса, РежимДиалогаВопрос.ДаНет);
		
	Иначе
		ОткрытьФорму("Справочник.EUF_ПроводникКонструкторИсходящихXML.Форма.ФормаВыбора", , ЭтаФорма, , , , , РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
	КонецЕсли;
		
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьДеревоИзПравилаЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт
	
	Ответ = РезультатВопроса;
	Если Ответ = КодВозвратаДиалога.Нет Тогда
		Возврат;
	КонецЕсли;	
	
	ОткрытьФорму("Справочник.EUF_ПроводникКонструкторИсходящихXML.Форма.ФормаВыбора", , ЭтаФорма, , , , , РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

&НаСервере
Функция СформироватьТекстЗапросаДляКонфигуратора(Текст)
	
	Если НЕ СтрНачинаетсяС(Текст, "ВЫБРАТЬ") тогда
		Возврат Текст;
	КонецЕсли;
	
	ТекстИсполняемогоКода = Справочники.EUF_ПроводникКонструкторИсходящихXML.ПолучитьМакет("ШаблонИсполняемогоКодаДляПолученияДанныхОбъекта").ПолучитьТекст();
	
	ПереводСтроки = Символы.ВК+Символы.ПС;
	
	Результат = "";
	
	Для Счетчик = 1 По СтрЧислоСтрок(Текст) Цикл
		ТекСтрока = СтрПолучитьСтроку(Текст, Счетчик);
		Если Счетчик > 1 Тогда 
			ТекСтрока = СтрЗаменить(ТекСтрока,"""","""""");
			ТекСтрока = СтрЗаменить(ТекСтрока,"","""");
			Результат = Результат + ПереводСтроки + "|"+ ТекСтрока;
		Иначе	
			ТекСтрока = СтрЗаменить(ТекСтрока,"""","""""");
			ТекСтрока = СтрЗаменить(ТекСтрока,"","""");
			Результат = Результат + ТекСтрока;
		КонецЕсли;	
	КонецЦикла;
	
	ТекстИсполняемогоКода = СтрЗаменить(ТекстИсполняемогоКода, "ТЕКСТ_ЗАПРОСА", Результат);
	
	Возврат ТекстИсполняемогоКода;
	
КонецФункции

&НаКлиенте
Процедура ОбработкаИзмененияСтроки(ВыбранноеЗначение)

	ДанныеСтроки = Новый Структура("ФормулаТега, Комментарий, НеВыгружать");			
	ТекДанныеДерева = Элементы.ДеревоПолейСообщения.ТекущиеДанные;
	
	ЗаполнитьЗначенияСвойств(ДанныеСтроки, ВыбранноеЗначение);	     	
	ЗаполнитьЗначенияСвойств(ТекДанныеДерева, ДанныеСтроки);
	
	Модифицированность = Истина;
	
КонецПроцедуры

&НаСервере
Процедура ЗаполнитьДеревоПолейПоТипуРекурсивно(Дерево, Пакет)
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Пакет.Имя);
	
	Попытка
		ТестСвойств = Пакет.Свойства;
	Исключение
		Пакет = Пакет.Тип;
	КонецПопытки;
	
	
	Для каждого СвойствоПакета из Пакет.Свойства цикл
		
		СтрокаДерева = Дерево.Строки.Добавить(); 
		
		СтрокаДерева.Поле 		= СвойствоПакета.Имя;
		СтрокаДерева.ИмяТипа 	= СвойствоПакета.Тип.Имя;
		
		Если ЗначениеЗаполнено(СтрокаДерева.ИмяТипа) И МассивТипов.Найти(СвойствоПакета.Тип.Имя) <> Неопределено тогда
			Продолжить;
		КонецЕсли;
		
		Попытка 
			ТестСвойстваПактеа = СвойствоПакета.Тип.Свойства;
		Исключение
			Продолжить;
		КонецПопытки;
		
		СтрокаДерева.ПространствоИмен 	= СвойствоПакета.Тип.URIПространстваИмен;
		
		ЗаполнитьДеревоПолейПоТипуРекурсивно(СтрокаДерева, СвойствоПакета.Тип);
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура ЗаполнитьДеревоПолейПоТипуСПояснениямиРекурсивно(Дерево, Пакет, НаборСхемXML, СписокУзловDOM, МассивРаскрытыхТипов = Неопределено)
	
	Попытка
		ТестСвойств = Пакет.Свойства;
	Исключение
		Пакет = Пакет.Тип;
	КонецПопытки;
	
	ИндексУзлаDOM = 0;
	
	Индексchoice = 0;
	
	СписокУзловDOMchoice = Неопределено;
	
	Если МассивРаскрытыхТипов = Неопределено тогда
		МассивРаскрытыхТипов = Новый Массив;
	КонецЕсли;
	
	Для каждого СвойствоПакета из Пакет.Свойства цикл
		
		СтрокаДерева = Дерево.Строки.Добавить(); 
		
		СтрокаДерева.Поле 		= СвойствоПакета.Имя;
		СтрокаДерева.ИмяТипа 	= СвойствоПакета.Тип.Имя;
		
		ИмяБазовогоТипа = "";
		
		Попытка 
			ТестБазовыйТип = СвойствоПакета.Тип.БазовыйТип;
			ИмяБазовогоТипа = ТестБазовыйТип.Имя;
		Исключение
		КонецПопытки;
		
		Если СписокУзловDOM <> Неопределено тогда
			
			ИндексУзлаDOM = ИндексУзлаDOM + 1;
			
			Если СписокУзловDOM.Количество() >= ИндексУзлаDOM Тогда
			
				Если СписокУзловDOMchoice = Неопределено И СписокУзловDOM[ИндексУзлаDOM-1].ЛокальноеИмя = "choice" тогда
					СписокУзловDOMchoice = СписокУзловDOM[ИндексУзлаDOM-1].ДочерниеУзлы;
				КонецЕсли;
				
				Если СписокУзловDOMchoice <> Неопределено тогда
					
					Индексchoice = Индексchoice + 1;
					
					Если СписокУзловDOMchoice.Количество() < Индексchoice тогда
						СписокУзловDOMchoice = Неопределено;
						ИндексУзлаDOM = ИндексУзлаDOM - Индексchoice + 2; 
					КонецЕсли;
					
				КонецЕсли;
				
				Попытка
					
					Если СписокУзловDOMchoice = Неопределено тогда
						СтрокаДерева.Комментарий = СокрЛП(СписокУзловDOM[ИндексУзлаDOM-1].ТекстовоеСодержимое);
					Иначе
						СтрокаДерева.Комментарий = СокрЛП(СписокУзловDOMchoice[Индексchoice-1].ТекстовоеСодержимое);
					КонецЕсли;
					
				Исключение
				КонецПопытки;
				
			КонецЕсли;

		КонецЕсли;
		
		Если СтрокаДерева.ИмяТипа = "" тогда
			СтрокаДерева.ИмяТипа = ИмяБазовогоТипа;	
		КонецЕсли;
		
		Попытка 
			ТестСвойстваПакета = СвойствоПакета.Тип.Свойства;
		Исключение
			Продолжить;
		КонецПопытки;
				
		СтрокаДерева.ПространствоИмен 	= СвойствоПакета.Тип.URIПространстваИмен;
		
		Если ЗначениеЗаполнено(СтрокаДерева.ИмяТипа) И МассивРаскрытыхТипов.Найти(СвойствоПакета.Тип.Имя) <> Неопределено тогда
			Продолжить;
		КонецЕсли;
		
		НовыйСписокУзловDOM = Неопределено;
		
		Если СписокУзловDOM <> Неопределено И НаборСхемXML <> Неопределено тогда
		
			Если ЗначениеЗаполнено(СтрокаДерева.ПространствоИмен) И ЗначениеЗаполнено(СтрокаДерева.ИмяТипа) тогда
				
				СхемаXML 			= НаборСхемXML.Получить(СтрокаДерева.ПространствоИмен);
				
				Если СхемаXML <> Неопределено тогда
					
					НовоеОпределениеXML = СхемаXML.ОпределенияТипов.Получить(СтрокаДерева.ИмяТипа);
					
					Если НовоеОпределениеXML <> Неопределено И НовоеОпределениеXML.ЭлементDOM.ДочерниеУзлы.Количество() > 1 тогда
						НовыйСписокУзловDOM = НовоеОпределениеXML.ЭлементDOM.ДочерниеУзлы[1].ДочерниеУзлы;
					Иначе
						НовыйСписокУзловDOM = СписокУзловDOM;
					КонецЕсли;
					
				Иначе
					НовыйСписокУзловDOM = СписокУзловDOM;
				КонецЕсли;
				
			Иначе
				НовыйСписокУзловDOM = СписокУзловDOM;
			КонецЕсли;
			
			Попытка
				
				Если СписокУзловDOMchoice = Неопределено тогда
					
					Если СписокУзловDOM[ИндексУзлаDOM-1].ДочерниеУзлы.Количество() 
							И СписокУзловDOM[ИндексУзлаDOM-1].ДочерниеУзлы[0].ЛокальноеИмя = "annotation"
						И СписокУзловDOM[ИндексУзлаDOM-1].ДочерниеУзлы[1].ЛокальноеИмя = "complexType" тогда
						
						СтрокаДерева.Комментарий = СокрЛП(СписокУзловDOM[ИндексУзлаDOM-1].ДочерниеУзлы[0].ТекстовоеСодержимое);
						
						НовыйСписокУзловDOM = СписокУзловDOM[ИндексУзлаDOM-1].ДочерниеУзлы[1].ДочерниеУзлы[0].ДочерниеУзлы;

					КонецЕсли;
					
				Иначе
					
					Если СписокУзловDOMchoice[Индексchoice-1].ДочерниеУзлы.Количество() 
							И СписокУзловDOMchoice[Индексchoice-1].ДочерниеУзлы[0].ЛокальноеИмя = "annotation"
						И СписокУзловDOMchoice[Индексchoice-1].ДочерниеУзлы[1].ЛокальноеИмя = "complexType" тогда
						
						СтрокаДерева.Комментарий = СокрЛП(СписокУзловDOMchoice[Индексchoice-1].ДочерниеУзлы[0].ТекстовоеСодержимое);
						
						НовыйСписокУзловDOM = СписокУзловDOMchoice[Индексchoice-1].ДочерниеУзлы[1].ДочерниеУзлы[0].ДочерниеУзлы;

					КонецЕсли;	
					
				КонецЕсли;
				
			Исключение
			КонецПопытки;
			
		КонецЕсли;
		
		Если СвойствоПакета.Тип.Имя <> "" тогда 
			МассивРаскрытыхТипов.Добавить(СвойствоПакета.Тип.Имя);
		КонецЕсли;
		Если Пакет.Имя <> "" тогда
			МассивРаскрытыхТипов.Добавить(Пакет.Имя);
		КонецЕсли;
		
		ЗаполнитьДеревоПолейПоТипуСПояснениямиРекурсивно(СтрокаДерева, СвойствоПакета.Тип, НаборСхемXML, НовыйСписокУзловDOM, МассивРаскрытыхТипов);
		
		МассивРаскрытыхТипов.Очистить();
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура ЗаполнитьСтрокиДереваФормыИзДереваХранилища(СтрокиДереваИзХранилища, СтрокиДереваФормы)
	           	
	Для Каждого СтрокаДереваИзХранилища Из СтрокиДереваИзХранилища Цикл
		НовСтрокаДереваФормы = СтрокиДереваФормы.Добавить();
		ЗаполнитьЗначенияСвойств(НовСтрокаДереваФормы, СтрокаДереваИзХранилища);
		Если СтрокаДереваИзХранилища.Строки.Количество() Тогда
			ЗаполнитьСтрокиДереваФормыИзДереваХранилища(СтрокаДереваИзХранилища.Строки, НовСтрокаДереваФормы.Строки);
		КонецЕсли;		
	КонецЦикла;
	
КонецПроцедуры	

&НаСервере
Функция ПолучитьПакетыТиповСхемыXSD(ВерсияСхемы, ПространствоИмен)
	
	ФабрикаXDTOВерсии = EUF_ПроводникПовтИсп.ПолучитьФабрикуXDTOПоВерсииСхемИнтеграции(ВерсияСхемы);
	
	Пакет = ФабрикаXDTOВерсии.Пакеты.Получить(ПространствоИмен);
	
	Возврат Пакет;
	
КонецФункции

&НаСервере
Функция ПолучитьСписокСтрокДереваДляКопирования(Источник)
	
	СЗ = Новый Массив;
	
	Если Источник.ПолучитьЭлементы().Количество() > 0 Тогда 
		
		Для Каждого Стр Из Источник.ПолучитьЭлементы() Цикл
			СЗ.Добавить(Стр);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СЗ;
	
КонецФункции

&НаСервере
Процедура ЗаполнитьРекурсивноЗначениеПоляЭлементТаблицыУПодчиненныхСтрок(Дерево, ЗначениеЭлементТаблицы)
	
	ПодчиненныеЭлементыДерева = Дерево.ПолучитьЭлементы();
	
	Для Каждого Стр Из ПодчиненныеЭлементыДерева Цикл
		Стр.ЭлементТаблицы = ЗначениеЭлементТаблицы;
		
		ЗаполнитьРекурсивноЗначениеПоляЭлементТаблицыУПодчиненныхСтрок(Стр, ЗначениеЭлементТаблицы);
	КонецЦикла;
		
КонецПроцедуры

&НаКлиенте
Процедура ОткрытьФормуРедактированияСтроки(ВыбранноеЗначение)
	
	Если ВыбранноеЗначение = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Если Не ТолькоПросмотр Тогда
		ЗаблокироватьДанныеФормыДляРедактирования();
	КонецЕсли;

	ДанныеСтроки 	= ДеревоПолейСообщения.НайтиПоИдентификатору(ВыбранноеЗначение);
				
	ПараметрыФормы = Новый Структура();
	
	ПараметрыФормы.Вставить("ТолькоПросмотр",       ТолькоПросмотр);
	ПараметрыФормы.Вставить("ИмяПоля",       		ДанныеСтроки.Поле);
	ПараметрыФормы.Вставить("АлгоритмЗаполнения", 	ДанныеСтроки.ФормулаТега);			
	ПараметрыФормы.Вставить("НеВыгружать",    		ДанныеСтроки.НеВыгружать);
	ПараметрыФормы.Вставить("Комментарий", 			ДанныеСтроки.Комментарий);
	ПараметрыФормы.Вставить("ЭлементТаблицы", 		ДанныеСтроки.ЭлементТаблицы);
		
	ОткрытьФорму("Справочник.EUF_ПроводникКонструкторИсходящихXML.Форма.ФормаРедактированияСтроки", ПараметрыФормы, ЭтаФорма, , , , , РежимОткрытияОкнаФормы.БлокироватьОкноВладельца);

КонецПроцедуры

&НаСервере
Процедура ЗаполнитьСписокВыбораЗначенийПолейДерева()
	
	ТекстЗапроса = Объект.АлгоритмПолученияДанных;
	
	Если Объект.ДанныеПолучатьВыполняемымАлгоритмом тогда
		ТекстЗапроса = EUF_ПроводникОбщегоНазначения.ПреобразоватьТекстАлгоритмаВТекстЗапроса(Объект.АлгоритмПолученияДанных);
	КонецЕсли;
	
	СтруктураПолейИсходящихДанных = EUF_ПроводникОбщегоНазначения.ПолучитьСтруктуруПолейЗапроса(ТекстЗапроса);
	
	Элементы.ДеревоПолейФормулаТега.СписокВыбора.Очистить();
	
	Для каждого ЭлементСтруктуры из СтруктураПолейИсходящихДанных цикл	
		
		Элементы.ДеревоПолейФормулаТега.СписокВыбора.Добавить("ИсходящиеДанные." + Строка(ЭлементСтруктуры.Ключ));
		
		Если ЗначениеЗаполнено(ЭлементСтруктуры.Значение) И ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Структура") тогда
			
			Для Каждого ЭлементСтруктурыТЗ из ЭлементСтруктуры.Значение цикл
				Элементы.ДеревоПолейФормулаТега.СписокВыбора.Добавить("СтрокаТаблицы." + Строка(ЭлементСтруктурыТЗ.Ключ));
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура ПроверитьЗаполнениеДереваНаСервере()
	
	ОбДерево = ДанныеФормыВЗначение(ДеревоПолейСообщения, Тип("ДеревоЗначений"));
	
	//Проверки заполенния дерева и реквизитов
	Отказ = Ложь;
	//EUF_ПроводникКонструкторСообщенийXML.ПроверитьЗаполнениеДереваСтруктураПолей(ОбДерево, Отказ);
	Если Не Отказ Тогда 
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Ошибок нет");		
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура ПроверитьЗаполнениеДерева(Команда)
	ПроверитьЗаполнениеДереваНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ПроверитьЗапрос(Команда)
	ОписаниеОшибки = "";
	//EUF_ПроводникКонструкторСообщенийXML.ПроверитьТекстЗапросНаФорме(СокрЛП(Объект.АлгоритмПолученияДанных), ОписаниеОшибки);
	//Сообщить(ОписаниеОшибки);
КонецПроцедуры

&НаСервере
Процедура ПроверитьАлгоритмНаСервере()
	//В данном поле указывается алгоритм обработки XML сообщения после заполнениями данными.
	//В алгоритме возможно использовать следующие переменные:
	//СообщениеXML - тип "ЗаписьXML", заполненное исходящими данными сообщение XML.
	//ИсходящиеДанные - тип "Структура", структура с исходящими данными.
	//ОбъектXSD - тип "ОбъектXDTO", заполненный исходящими данными объект XDTO. 
	
	СообщениеXML = Новый ЗаписьXML;	
	ИсходящиеДанные = Новый Структура;
	
	ФабрикаXDTOСообщения = EUF_ПроводникПовтИсп.ПолучитьФабрикуXDTOПоВерсииСхемИнтеграции(Объект.ВерсияСхемы);
	
	Пакет = ФабрикаXDTOСообщения.Пакеты.Получить(Объект.URIПространстваИменПакета);
	
	ТипПакета = Пакет.Получить(Объект.КорневойУзел);
		
	ОбъектXSD = ФабрикаXDTOСообщения.Создать(ТипПакета);
		
	Попытка
		Выполнить(СокрЛП(Объект.АлгоритмПослеФормированияСообщения));
		Сообщить("Ошибок нет");
	Исключение
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры

&НаКлиенте
Процедура ПроверитьАлгоритм(Команда)
	ПроверитьАлгоритмНаСервере();
КонецПроцедуры

#КонецОбласти

